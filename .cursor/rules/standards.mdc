---
alwaysApply: true
description: This file contains the standards for the codebase.
---

## The product vision

The overall vision for this project is in [product-vision.md](./docs/product-vision.md). This doc is the source of truth for business requirements. Individual user prompts may override these requirements. If so, the vision doc should be updated.

## Codebase Structure

- All Next.js pages should be in the `src/app` directory.
- Componets that are re-used across multiple pages should be in the `src/components` directory.
- Components that are only used in a single page should be colocated with the page in the `src/app` directory.
- Database operations should be in the `src/db` directory.
- Business logic functions should be in the `src/services` directory.
- Shared validation schemas (used by both UI forms and services) should be in the `src/validators` directory.
- Server Actions should be colocated with the page in the `src/app` directory, unless the action is used in multiple pages, in which case it should be in the `src/actions` directory.
- Shared library code should be in the `src/lib` directory, organized by execution context:
  - `src/lib/client/` - Code that runs only on the client (React hooks, browser APIs, client-side auth)
  - `src/lib/server/` - Code that runs only on the server (database calls, server-side auth, API integrations)
  - `src/lib/shared/` - Pure functions and constants that can run in both contexts (utilities, type helpers, constants)

## General Standards

- Keep code DRY (Don't Repeat Yourself), do not repeat business logic in multiple place. Do not repeat UI fragments in multiple places. Make reusable functions and components.
- Maintain type safety by defining input and output types for functions and components (one exception is components do not need output types).
- **TypeScript error suppression is NOT allowed.** Never use `@ts-ignore`, `@ts-expect-error`, or `@ts-nocheck`. All type errors must be properly fixed, not suppressed. The build must pass TypeScript checks without any suppression comments.
- Only write code that is going to be used. Do not make functions or components that are unused.
- In general, less code is better. Its less to maintain, less bugs to have, less to read, etc.
- Comments in the code should be minimal. Code comments should only ever be needed to explain WHY, but never WHAT. The code already says WHAT.
- All text fields that can be filled out by a user should have a sensible limit both at the database layer and zod validation layer. They should re-use the same constant value
- Shared domain constants (e.g., role hierarchies, labels) and utility functions should be placed in `src/lib` for reuse across services and UI components.
- Use enums or equivalent types wherever possible as opposed to repeating string literals across the codebase

## Authentication Standards

We use Better Auth for authentication. Consult the [Better Auth Documentation](https://better-auth.com/docs) for how to use the library.

In this codebase in particular:

- When working with auth on the server, use `src/lib/server/auth.ts` to authenticate requests.
- When working with auth on the client, use `src/lib/client/auth.ts` to authenticate requests.

## UI Component Standards

### Participant Display
When displaying participants (users, teams, or placeholder members) in the UI, always use the `ParticipantDisplay` component from `@/components/participant-display` for consistency:

```typescript
import { ParticipantData, ParticipantDisplay } from "@/components/participant-display";

const participant: ParticipantData = {
  user: entry.user,
  team: entry.team,
  placeholderMember: entry.placeholderMember,
};

<ParticipantDisplay
  participant={participant}
  showAvatar
  showUsername
  size="sm"
/>
```

This ensures consistent rendering of avatars, names, and usernames across the entire application.

### React List Keys
When rendering lists in React where the same item might appear multiple times (e.g., leaderboards showing multiple scores from the same user), **always use unique identifiers for keys**, never participant IDs or composite keys that could duplicate:

```typescript
// Good: Uses unique entry ID
{leaderboard.map((entry) => (
  <div key={entry.entryId}>...</div>
))}

// Bad: Uses participant ID (same participant can appear multiple times)
{leaderboard.map((entry) => (
  <div key={entry.participantId}>...</div>
))}
```

### Number Input Forms
For number input fields that should allow decimals and empty values:

1. **Default values**: Use empty string with type assertion: `score: "" as any`
2. **Input attributes**: Add `step="any"` to allow decimals, remove `min` and `max` unless specifically needed
3. **onChange handler**: Preserve empty string or parse as float:

```typescript
onChange={(e) => {
  const value = e.target.value;
  field.onChange(value === "" ? "" : parseFloat(value));
}}
```

This allows users to:
- Clear the field completely
- Enter decimal values
- Enter negative values
- Backspace without issues

## Database Standards

We use Drizzle ORM for database operations and integration with Postgres and Neon.

- All schema changes should have a migration file generated by running `pnpm run db:generate` and can then be applied by running `pnpm run db:migrate`.
- Database operations should be done in the `src/db` directory, in a file named based on the business domain for the database operations. For example, if the database operations are related to users, the file should be named `users.ts`.
- Database functions should support being run on their own AND within a transaction.
- Database functions should be named in a format of <action><subject><queryType>. For example, `createUser`, `getUserById`, `updateUserEmail`.
- Database query functions should generally be limited to a single query unless the query is complex or requires multiple steps.
- Database functions should be very limited in business logic
- Database functions should only be called by service functions, and never directly by other functions or components.
- Database Types can be made by using DrizzleORM's `inferSelect` and `inferInsert` functions, and should be used. These can be defined in the `src/db/schema.ts` file.
- Table column extractions using `getTableColumns` should be exported from `src/db/schema.ts` for reuse across db files, rather than duplicating the extraction in multiple files.
- **Score columns must use `real()` type** (PostgreSQL REAL, 4-byte floating point) to support decimal and negative values. Never use `integer()` for score columns as this prevents decimal scores (e.g., 98.5) which are valid in many game types.

## Next.js Standards

- All Next.js pages should be server components.
- All Next.js components should be server components unless client reactivity is needed.
- Query and Path parameters should be validated using zod and handled gracefully if the validation fails.
- Server components when fetching data should not make direct database calls, but should call a business logic function that will handle the database call.
- Server components that fetch data should be async functions and utilize [Streaming](https://nextjs.org/docs/app/getting-started/fetching-data#streaming) to fetch data from the server. A `loading.ts` file can be used for route segements (layouts and pages), but if the loading is more granular, Suspense can be used to handle the loading state.
- In general, we should use Server Components where possible. Anytime client reactivity is needed, we should use Client Components, but instead of making a large component a client component, we should split it into smaller components that are client components where the interactivity is needed, but still maintain a server component that uses the client components to render the page.
- All Next.js API routes should be in the `src/app/api` directory. API routes are only need if an external app needs to integrate with the app. Internally, we should use server actions.
- Layouts should be used for shared UI layouts across different pages

### Server Actions Standards
- Server Actions should always take in an "unknown" type for the input and pass it to a service function to handle the business logic and validation
- Server Actions should be thin, only focusing on:
  1. Authenticating the user
  2. Calling the service function with unknown input
  3. Handling the service result (revalidating cache, redirecting, etc.)
  4. Returning the result to the client
- **Server Actions MUST NOT use unvalidated input for ANY purpose**, including:
  - Cache invalidation paths
  - Redirects
  - Logging
  - Any other operations
- If data is needed for cache invalidation or redirects, it should be returned from the service function after validation
- Use `revalidatePath()` with data returned from services, not from raw user input

**Example of correct Server Action:**
```typescript
export async function createTeamAction(input: unknown) {
  const user = await getUser();
  if (!user) return { error: "Not authenticated" };

  const result = await createTeam(user.id, input);

  if (result.data) {
    // Use validated data from service for cache invalidation
    revalidatePath(`/leagues/${result.data.leagueId}/teams`);
  }

  return result;
}
```

**Example of incorrect Server Action:**
```typescript
// BAD: Uses unvalidated input for cache invalidation
export async function createTeamAction(input: unknown) {
  const user = await getUser();
  const result = await createTeam(user.id, input);

  // WRONG: input.leagueId is unvalidated user input
  revalidatePath(`/leagues/${input.leagueId}/teams`);

  return result;
}
```

## Service Standards

Business logic functions should be in the `src/services` directory.

### General Service Principles
- Services should call database functions, but nothing else should call them
- Services should have unit tests, mocking external dependencies and only testing input and output. Tests should NOT use `toHaveBeenCalled` or `toHaveBeenCalledWith` - only verify outputs based on mocked inputs.
- The idea behind this is to put as much business logic in the service layer, so that if we ever want to change to a separate API layer, we can do so with minimal changes to the business logic.

### Input Validation
- Services MUST validate all input parameters FIRST before executing any business logic
- Services should take in an "unknown" type for the input and use zod to validate it at the start of the function
- Validation errors should be returned immediately before any database calls or permission checks
- This ensures that validation failures are caught early and prevents unnecessary processing

### Function Signature Patterns

**For functions with simple inputs (single ID or simple data object):**
```typescript
export async function getGameType(
  userId: string,
  gameTypeId: string
): Promise<ServiceResult<GameType>>
```

**For mutation functions where IDs and form data are separate:**
Use the idInput/dataInput pattern to keep identifiers separate from form data:
```typescript
export async function updateGameType(
  userId: string,
  idInput: unknown,  // e.g., { gameTypeId: string }
  dataInput: unknown, // e.g., { name?: string, config?: {...} }
): Promise<ServiceResult<GameType>>
```

**For functions where the data itself contains the ID:**
Include the ID (like leagueId) in the input schema rather than as a separate parameter:
```typescript
export async function createTeam(
  userId: string,
  input: unknown, // includes { leagueId, name, ... }
): Promise<ServiceResult<Team>>
```

**For simple action functions (archive, delete, etc.):**
```typescript
export async function archiveTeam(
  userId: string,
  input: unknown, // e.g., { teamId: string }
): Promise<ServiceResult<void>>
```

### Return Values for Cache Invalidation
- Services should return data needed for client-side cache invalidation
- For mutations, include relevant IDs (leagueId, teamId, etc.) in the return value
- This allows server actions to invalidate the correct cache paths without using unvalidated input

**Examples:**
```typescript
// Good: Returns leagueId for cache invalidation
return { data: { created: true, leagueId } };

// Good: Returns both confirmation and necessary IDs
return { data: { invited: true, invitationId, leagueId } };

// Bad: Only returns confirmation without cache invalidation data
return { data: { created: true } };
```

## Validation Standards

We use Zod for validation. Validation schemas that are shared between the UI (forms) and the backend (services) should be placed in the `src/validators` directory.

- Shared schemas should be in `src/validators`, organized by domain (e.g., `users.ts`, `leagues.ts`).
- Define base field schemas (e.g., `usernameSchema`, `nameSchema`) that can be composed into larger schemas.
- Services can extend shared schemas (e.g., adding `.transform()` or `.optional()`) as needed.
- UI forms should import and use the shared schemas directly for react-hook-form validation.
- Validation schemas that are only used in one place (e.g., only in a service or only in a form) do not need to be in `src/validators`.
- **Form validation schemas MUST be shared between the client form and the service function** to ensure validation is consistent and avoid drift. If a form submits to a server action that calls a service, both the form and the service should use the same schema from `src/validators`.

### Numeric Validation
For score and numeric input fields:

- **Allow decimals and negative numbers** unless the business logic specifically prohibits them: `z.number("A number is required")`
- **Avoid `.int()` constraint** on scores - many games have decimal scores (e.g., Golf, Bowling)
- **Avoid `.min(0)` constraint** on scores - some games use negative scores (e.g., card games, golf relative to par)
- **Use user-friendly error messages**: `z.number("A number is required")` instead of `z.number()` which produces technical "Expected number, received string" errors
- These constraints should only be added when the specific game type or business logic requires them, not as a blanket policy

## Styling Standards

We use ShadCN's Component Library for styling.

- We should be use components from the library where possible, and avoid creating custom components unless absolutely necessary.
- consult the [ShadCN Component Library](https://ui.shadcn.com/docs/components) for the available components.
- Arbitrary colors should not be used. Instead, use the theme colors defined in the `globals.css` file. If a new color is needed, add it to the `globals.css` file.
- The entire app should be mobile-first, and should be responsive to different screen sizes.

## UX/UI Feedback Standards

- Use `sonner` for toast notifications for success messages and root-level errors.
- Use inline form field errors for specific validation issues.
- Use `loading.tsx` and Suspense boundaries for loading states.

## Error Handling Standards

- Use `error.tsx` for route-level error boundaries.
- Server actions should return `ServiceResult<T>` and catch unexpected errors.

## SEO Standards

- All pages should have appropriate metadata (title, description).
- Dynamic pages should use `generateMetadata`.
